---+ Adding types

Docs: https://lirias.kuleuven.be/bitstream/123456789/197561/1/shorticlp08.pdf

---++ What we want from a type declarations

  * Allow exporting types and provide visibility of types silimar to
    predicates and operators.

  * Access predicates:
    - <type>(X) is semidet.
    - type_constraint(:Type, X)

  * A type hierarchy as a multiple-inheritance hierarchy.

  * Interesting challenges:

	type_constraint(atom, X),
	type_constraint(list, X)
		--> X = []

	type_constraint(compound, X),
	type_constraint(list, X)
		--> X = [_|T], type_constraint(list, T).

	- Atomic types: see whether type decl has actual values that
	  match.  Then, replace by eq-constraint?
	- Compound:

---+++ Hindley-Milner types

  ==
  :- type list --->
	( []
	; [_|list]
	).
  :- type list(X) --->
	( []
	; [X|list]
	).
  :- type boolean --->
	( true
	; false
	).
  :- type write_option --->
	( quoted(boolean)
	; ...
	).
  ==

---++++ Type inheritance

  ==
  :- type boolean < [atom] --->
	( true
	; false
	).
  :- type integer < [number].
  :- type atom < [atomic].
  :- type number < [atomic].
  :- type stream.
  ==




---++ We also need modes

  $ + :
  Input argument.  Satisfies the given type at entry
  $ - :
  Output argument.  Satisfies the given type at exit
  $ ? :
  Input/output argument.  Satisfies the given type at exit
  $ @ :
  Input argument.  Left unmodified.

---+ Attributed approach

Attributes:

	* name
	* type
	* instantiated
